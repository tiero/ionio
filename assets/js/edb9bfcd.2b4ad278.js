"use strict";(self.webpackChunkionio_website=self.webpackChunkionio_website||[]).push([[341],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),u=c(a),d=i,m=u["".concat(s,".").concat(d)]||u[d]||p[d]||o;return a?n.createElement(m,r(r({ref:t},h),{},{components:a})):n.createElement(m,r({ref:t},h))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},696:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return h},default:function(){return u}});var n=a(7462),i=a(3366),o=(a(7294),a(3905)),r=["components"],l={},s="Example Contracts",c={unversionedId:"language/ExampleContracts",id:"language/ExampleContracts",title:"Example Contracts",description:"Below are some examples of contract templates written in Ivy. You can try out these contracts in the playground, where they are preloaded as default templates.",source:"@site/docs/language/ExampleContracts.md",sourceDirName:"language",slug:"/language/ExampleContracts",permalink:"/docs/language/ExampleContracts",editUrl:"https://github.com/ionio-lang/ionio/tree/main/website/docs/language/ExampleContracts.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bitcoin Script",permalink:"/docs/language/BitcoinScript"},next:{title:"Functions",permalink:"/docs/language/Functions"}},h=[{value:"LockWithPublicKey",id:"lockwithpublickey",children:[],level:2},{value:"LockWithMultiSig",id:"lockwithmultisig",children:[],level:2},{value:"LockWithPublicKeyHash",id:"lockwithpublickeyhash",children:[],level:2},{value:"RevealPreimage",id:"revealpreimage",children:[],level:2},{value:"RevealCollision",id:"revealcollision",children:[],level:2},{value:"RevealFixedPoint",id:"revealfixedpoint",children:[],level:2},{value:"LockUntil",id:"lockuntil",children:[],level:2},{value:"LockDelay",id:"lockdelay",children:[],level:2},{value:"TransferWithTimeout",id:"transferwithtimeout",children:[],level:2},{value:"ToLocal",id:"tolocal",children:[],level:2},{value:"EscrowWithDelay",id:"escrowwithdelay",children:[],level:2},{value:"VaultSpend",id:"vaultspend",children:[],level:2},{value:"HTLC",id:"htlc",children:[],level:2}],p={toc:h};function u(e){var t=e.components,a=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"example-contracts"},"Example Contracts"),(0,o.kt)("p",null,"Below are some examples of contract templates written in Ivy. You can try out these contracts in the playground, where they are preloaded as default templates."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#lockwithpublickey"},"LockWithPublicKey")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#lockwithmultisig"},"LockWithMultiSig")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#lockwithpublickeyhash"},"LockWithPublicKeyHash")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#revealpreimage"},"RevealPreimage")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#revealcollision"},"RevealCollision")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#revealfixedpoint"},"RevealFixedPoint")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#lockuntil"},"LockUntil")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#lockdelay"},"LockDelay")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#transferwithtimeout"},"TransferWithTimeout")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#tolocal"},"ToLocal")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#escrowwithdelay"},"EscrowWithDelay")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#vaultspend"},"VaultSpend")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#htlc"},"HTLC"))),(0,o.kt)("p",null,"These contracts demonstrate the following conditions supported by Bitcoin Script:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Requiring a signature corresponding to a prespecified public key (see ",(0,o.kt)("a",{parentName:"p",href:"#lockwithpublickey"},"LockWithPublicKey"),")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Requiring M signatures corresponding to any of N prespecified public keys (see ",(0,o.kt)("a",{parentName:"p",href:"#lockwithmultisig"},"LockWithMultisig"),")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Checking that the cryptographic hash of a string or public key is equal to a prespecified hash (see ",(0,o.kt)("a",{parentName:"p",href:"#lockwithpublickeyhash"},"LockWithPublicKeyHash"),", ",(0,o.kt)("a",{parentName:"p",href:"#revealcollision"},"RevealCollision"),", ",(0,o.kt)("a",{parentName:"p",href:"#revealpreimage"},"RevealPreimage"),", ",(0,o.kt)("a",{parentName:"p",href:"#revealfixedpoint"},"RevealFixedPoint"),")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Waiting until after a specified block height or block time (see ",(0,o.kt)("a",{parentName:"p",href:"#lockuntil"},"LockUntil"),", ",(0,o.kt)("a",{parentName:"p",href:"#transferwithtimeout"},"TransferWithTimeout"),")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Waiting until the contract has been on the blockchain for longer than a specified duration (see ",(0,o.kt)("a",{parentName:"p",href:"#lockdelay"},"LockDelay"),", ",(0,o.kt)("a",{parentName:"p",href:"#escrowwithdelay"},"EscrowWithDelay"),", ",(0,o.kt)("a",{parentName:"p",href:"#vaultspend"},"VaultSpend"),")"))),(0,o.kt)("h2",{id:"lockwithpublickey"},"LockWithPublicKey"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract LockWithPublicKey(publicKey: PublicKey, val: Value) {\n  clause spend(sig: Signature) {\n    verify checkSig(publicKey, sig)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"LockWithPublicKey creates a simple Bitcoin address. A public key is specified at the time the contract is created. To spend from the contract, the user must provide a signature on the spending transaction from that public key."),(0,o.kt)("p",null,"All Bitcoin addresses produced by the Ivy compiler are ",(0,o.kt)("a",{parentName:"p",href:"https://bitcoincore.org/en/segwit_wallet_dev/"},"SegWit addresses"),". However, unlike the other contracts, which compile to Pay-To-Witness-Script-Hash addresses, LockWithPublicKey compiles to a Pay-To-Witness-Public-Key-Hash address, a special (slightly more efficient) format for addresses that are controlled by a single public key."),(0,o.kt)("h2",{id:"lockwithmultisig"},"LockWithMultiSig"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract LockWithMultisig(\n  pubKey1: PublicKey,\n  pubKey2: PublicKey,\n  pubKey3: PublicKey,\n  val: Value\n) {\n  clause spend(sig1: Signature, sig2: Signature) {\n    verify checkMultiSig([pubKey1, pubKey2, pubKey3], [sig1, sig2])\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"LockWithMultiSig creates a multisig address. Three public keys are specified at the time the contract is created. To spend from the contract, the user must provide signatures on the spending transaction from two of the three public keys."),(0,o.kt)("h2",{id:"lockwithpublickeyhash"},"LockWithPublicKeyHash"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract LockWithPublicKeyHash(pubKeyHash: Sha256(PublicKey), val: Value) {\n  clause spend(pubKey: PublicKey, sig: Signature) {\n    verify sha256(pubKey) == pubKeyHash\n    verify checkSig(pubKey, sig)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"LockWithPublicKeyHash is similar to the ",(0,o.kt)("a",{parentName:"p",href:"#lockwithpublickey"},"LockWithPublicKey")," contract, except instead of taking a public key as a contract argument, it takes the SHA256 hash of that public key. Then, when it is spent, it expects an additional argument, the public key. The public key is hashed and compared to the ",(0,o.kt)("inlineCode",{parentName:"p"},"pubKeyHash")," contract argument before the signature is checked."),(0,o.kt)("p",null,"There is not much reason to use this contract, particularly since modern Bitcoin addresses only reveal a hash of their script anyway, so their contract arguments are never explicitly revealed. Indeed, the ",(0,o.kt)("inlineCode",{parentName:"p"},"publicKey")," argument to the ",(0,o.kt)("a",{parentName:"p",href:"#lockwithpublickey"},"LockWithPublicKey")," contract is hashed ",(0,o.kt)("a",{parentName:"p",href:"https://bitcoincore.org/en/segwit_wallet_dev/#creation-of-p2sh-p2wpkh-address"},"four times")," before it included in the generated address."),(0,o.kt)("h2",{id:"revealpreimage"},"RevealPreimage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract RevealPreimage(hash: Sha256(Bytes), val: Value) {\n  clause reveal(string: Bytes) {\n    verify sha256(string) == hash\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"RevealPreimage can be unlocked by providing the preimage for a prespecified SHA256 hash digest."),(0,o.kt)("p",null,"This contract is typically not useful, since unlike a signature, a hash preimage is not tied to a specific spending transaction. If you tried to spend this contract by revealing the preimage, there would be nothing to stop a miner who saw your transaction from replacing it with a transaction that uses that preimage to unlock the contract and spend it to themselves."),(0,o.kt)("h2",{id:"revealcollision"},"RevealCollision"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract RevealCollision(val: Value) {\n  clause reveal(string1: Bytes, string2: Bytes) {\n    verify string1 != string2\n    verify sha1(string1) == sha1(string2)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"RevealCollision pays a reward to anyone who provides a SHA1 collision\u2014two different bytestrings whose SHA1 hashes are equal."),(0,o.kt)("p",null,"Peter Todd used this script to ",(0,o.kt)("a",{parentName:"p",href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2013-September/003253.html"},"post a bounty")," on collisions for several hash functions. When a SHA1 collision was ",(0,o.kt)("a",{parentName:"p",href:"https://shattered.io/"},"found in February 2017"),", someone used that collision to ",(0,o.kt)("a",{parentName:"p",href:"https://tradeblock.com/bitcoin/tx/8d31992805518fd62daa3bdd2a5c4fd2cd3054c9b3dca1d78055e9528cff6adc"},"claim the bounty"),"."),(0,o.kt)("p",null,"As with the ",(0,o.kt)("a",{parentName:"p",href:"#revealpreimage"},"RevealPreimage")," contract, any attempt to spend this contract could potentially be sniped by miners."),(0,o.kt)("h2",{id:"revealfixedpoint"},"RevealFixedPoint"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract RevealFixedPoint(val: Value) {\n  clause reveal(hash: Bytes) {\n    verify bytes(sha256(hash)) == hash\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"RevealFixedPoint is similar to ",(0,o.kt)("a",{parentName:"p",href:"#revealcollision"},"RevealCollision"),", except the challenge is to reveal a SHA256 ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/One-way_compression_function#cite_ref-8"},"fixed point"),", rather than a SHA1 collision."),(0,o.kt)("p",null,"In order to compare a SHA256 hash with its preimage, the former needs to be coerced to a bytestring, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"bytes")," function. This has no effect on script execution, but prevents the typechecker from objecting to the comparison."),(0,o.kt)("h2",{id:"lockuntil"},"LockUntil"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract LockUntil(publicKey: PublicKey, time: Time, val: Value) {\n  clause spend(sig: Signature) {\n    verify checkSig(publicKey, sig)\n    verify after(time)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"LockUntil is similar to ",(0,o.kt)("a",{parentName:"p",href:"#lockwithpublickey"},"LockWithPublicKey"),", but adds an additional condition known as a timelock\u2014it can only be spent after a particular time has passed."),(0,o.kt)("p",null,"Absolute timelocks (which use the ",(0,o.kt)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/NLockTime"},"nLockTime")," field of the spending transaction and the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki"},"CHECKLOCKTIMEVERIFY")," opcode) can be used to prevent yourself from withdrawing Bitcoin before a certain time. They are also useful for some more sophisticated applications, such as ",(0,o.kt)("a",{parentName:"p",href:"#escrowwithdelay"},"escrow")," or ",(0,o.kt)("a",{parentName:"p",href:"#transferwithtimeout"},"payment channels"),"."),(0,o.kt)("h2",{id:"lockdelay"},"LockDelay"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract LockDelay(publicKey: PublicKey, delay: Duration, val: Value) {\n  clause spend(sig: Signature) {\n    verify checkSig(publicKey, sig)\n    verify older(delay)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"LockDelay is similar to ",(0,o.kt)("a",{parentName:"p",href:"#lockuntil"},"LockUntil"),", but instead of an absolute timelock, it uses a relative timelock\u2014it can only be spent a certain amount of time after the contract has been added to the blockchain."),(0,o.kt)("p",null,"Relative timelocks (which use the transaction input's ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki"},"sequence number")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki"},"CHECKSEQUENCEVERIFY")," opcode) can be more convenient than absolute locktimes, but they can also enable some powerful additional features in protocols such as payment channels."),(0,o.kt)("h2",{id:"transferwithtimeout"},"TransferWithTimeout"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract TransferWithTimeout(\n  sender: PublicKey,\n  recipient: PublicKey,\n  timeout: Time,\n  val: Value\n) {\n  clause transfer(senderSig: Signature, recipientSig: Signature) {\n    verify checkSig(sender, senderSig)\n    verify checkSig(recipient, recipientSig)\n    unlock val\n  }\n  clause timeout(senderSig: Signature) {\n    verify checkSig(sender, senderSig)\n    verify after(timeout)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"TransferWithTimeout is our first example that has more than one clause. To satisfy such a contract, you only need to satisfy ",(0,o.kt)("em",{parentName:"p"},"one")," of the clauses."),(0,o.kt)("p",null,'This contract is instantiated with two public keys, corresponding to the "sender" and the "recipient" of some transfer. The contract can be spent by the mutual agreement of both parties.'),(0,o.kt)("p",null,"This contract could be used to create a primitive one-way payment channel. Suppose Alice wants to make a series of micropayments to Bob (for example, because she is browsing a publication owned by Bob, or watching a movie that she is paying for by the minute), but doesn't want to pay a transaction fee for every one of them."),(0,o.kt)("p",null,"Alice can prefund this TransferWithTimeOut contract with 10 BTC, using her own public key as the ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," and Bob's key as the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),". She can then create a transaction that sends some small portion of the contract\u2014say, .00001 BTC\u2014to Bob, but sends the rest back to herself. She signs that transaction and sends it to Bob (but doesn't send it to the blockchain). Bob only needs to add his signature to claim his .00001 BTC, but he can also wait for further payments. "),(0,o.kt)("p",null,"Alice can then send additional micropayments on this channel by creating new transactions that spend the same contract but send increasing amounts to Bob. Whenever Bob wants to close the channel, he signs and publishes only the ",(0,o.kt)("em",{parentName:"p"},"last")," of those transactions, which sends Alice's total payment to him and returns the remaining change to her."),(0,o.kt)("p",null,"What happens if Bob disappears, or refuses to sign any transactions? That's what the ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout")," clause is for. After the channel's expiration time, Alice can call the ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout")," clause to reclaim all of the Bitcoin she used to prefund the channel. This prevents Alice's money from being locked up forever if Bob refuses to cooperate."),(0,o.kt)("h2",{id:"tolocal"},"ToLocal"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract ToLocal(\n  localDelayedPubKey: PublicKey,\n  revocationPubKey: PublicKey,\n  toSelfDelay: Duration,\n  val: Value\n) {\n  clause reveal(revocationSig: Signature) {\n    verify checkSig(revocationPubKey, revocationSig)\n    unlock val\n  }\n  clause timeout(localDelayedSig: Signature) {\n    verify checkSig(localDelayedPubKey, localDelayedSig)\n    verify older(toSelfDelay)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"This contract can be used as part of a bidirectional payment channel similar to those used in the Lightning Network, as described ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/lightningnetwork/lightning-rfc/blob/master/03-transactions.md#to_local-output"},"here"),". This contract would be used as an output of a commitment transaction (which represents a state that the parties agree to off-chain)."),(0,o.kt)("p",null,"It is similar to the previous contract because it includes a timeout clause (the last one) with a single signature. However, this timeout is not for the depositor of the funds to claim them in case the other party is not cooperative, but is a time window left open for any disputes to be presented after one party tries to close the channel. Such a dispute can arise if the party that sent the on-chain transaction to close the channel is trying to propagate a state of the channel which is not valid anymore (as it might have been invalidated by subsequent off-chain transactions). In such a case, the party that didn't attempt to close the channel has this timeout available to withdraw all the funds in a punishment transaction, using the revocation private key that she learned when the channel state was invalidated."),(0,o.kt)("h2",{id:"escrowwithdelay"},"EscrowWithDelay"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract EscrowWithDelay(\n  sender: PublicKey,\n  recipient: PublicKey,\n  escrow: PublicKey,\n  delay: Duration,\n  val: Value\n) {\n  clause transfer(sig1: Signature, sig2: Signature) {\n    verify checkMultiSig(\n      [sender, recipient, escrow], \n      [sig1, sig2]\n    )\n    unlock val\n  }\n  clause timeout(sig: Signature) {\n    verify checkSig(sender, sig)\n    verify older(delay)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"EscrowWithDelay implements a simple escrow contract. When it is instantiated, three keys are specified\u2014one for the ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," of the transfer, one for the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),", and one for an ",(0,o.kt)("inlineCode",{parentName:"p"},"escrow")," agent."),(0,o.kt)("p",null,"The escrow agent can approve or cancel the transfer with the cooperation of one of the other parties, but cannot steal the money for himself."),(0,o.kt)("p",null,"If the escrow agent and recipient both fail to cooperate, then after the expiration time, the sender is able to cancel the transfer and recover the money with the ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout")," clause."),(0,o.kt)("p",null,"You can imagine variants of this contract that, for example, give the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient")," the funds in the event of a timeout instead of the ",(0,o.kt)("inlineCode",{parentName:"p"},"sender"),"."),(0,o.kt)("h2",{id:"vaultspend"},"VaultSpend"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract VaultSpend(\n  hotKey: PublicKey,\n  coldKey: PublicKey,\n  delay: Duration,\n  val: Value\n) {\n  clause cancel(sig: Signature) {\n    verify checkSig(coldKey, sig)\n    unlock val\n  }\n  clause complete(sig: Signature) {\n    verify older(delay)\n    verify checkSig(hotKey, sig)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"VaultSpend implements a simple form of ",(0,o.kt)("a",{parentName:"p",href:"http://fc16.ifca.ai/bitcoin/papers/MES16.pdf"},(0,o.kt)("em",{parentName:"a"},"vault")),", a mechanism for securing Bitcoin held in cold storage."),(0,o.kt)("p",null,"This contract is instantiated with two public keys: a ",(0,o.kt)("inlineCode",{parentName:"p"},"hotKey")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"coldKey"),'. The "hot key" could be kept on a computer or server; the "cold key"\u2014or "cancellation key"\u2014would be kept somewhere offline and hard to get to, such as a paper wallet in a safety deposit box.'),(0,o.kt)("p",null,"You would not actually store your funds in ",(0,o.kt)("em",{parentName:"p"},"this")," contract. Instead, you could hold funds in a LockWithPublicKey contract secured by ",(0,o.kt)("inlineCode",{parentName:"p"},"coldKey"),", and then ",(0,o.kt)("em",{parentName:"p"},"presign")," a transaction that spends it into this contract. You could keep the presigned transaction on the same server as the hot key. "),(0,o.kt)("p",null,"To withdraw the funds, you could use the presigned transaction to move them into this contract. After the ",(0,o.kt)("inlineCode",{parentName:"p"},"delay")," has passed, you could then use the hot key to move the funds wherever you want to send them."),(0,o.kt)("p",null,"If an attacker compromises your server and steals the presigned transaction and hot key, they would only be able to move the money into this contract. The time delay would then give you enough time to notice, retrieve your cold key, and move the money to a safer contract."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"http://fc16.ifca.ai/bitcoin/papers/MES16.pdf"},"initial design")," for vaults by M\xf6ser, Eyal, and Sirer depended on a feature, covenants, that is not yet supported in Bitcoin Script. The implementation of vaults described above makes use of only existing Bitcoin Script features, but has some key limitations. Most importantly, an attacker who surreptitiously steals the hot key could wait for the owner to attempt a hot-key withdrawal, then, after the delay has expired, spend the transaction before the owner is able to. Until Bitcoin adds support for covenants (if ever), it may not be possible to fully implement a vault."),(0,o.kt)("h2",{id:"htlc"},"HTLC"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"contract HTLC(\n  sender: PublicKey, \n  recipient: PublicKey,\n  expiration: Time,\n  hash: Sha256(Bytes),\n  val: Value\n) {\n  clause complete(preimage: Bytes, sig: Signature) {\n    verify sha256(preimage) == hash\n    verify checkSig(recipient, sig)\n    unlock val\n  }\n  clause cancel(sig: Signature) {\n    verify after(expiration)\n    verify checkSig(sender, sig)\n    unlock val\n  }\n}\n")),(0,o.kt)("p",null,"HTLC is an implementation of a Hashed Timelock Contract, a construction that can be used to enable trustless exchanges of cryptocurrencies on completely different blockchain networks (such as trading Bitcoin for Ether), as well as multihop payments on payment channel networks such as the Lightning Network."),(0,o.kt)("p",null,"Before an HTLC is created, one party, the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),", generates a secret ",(0,o.kt)("inlineCode",{parentName:"p"},"preimage"),", hashes it, and provides the hash, ",(0,o.kt)("inlineCode",{parentName:"p"},"hash"),", to the other party, ",(0,o.kt)("inlineCode",{parentName:"p"},"sender"),"."),(0,o.kt)("p",null,"In the normal case, an HTLC can be completed by the ",(0,o.kt)("inlineCode",{parentName:"p"},"recipient"),", by revealing the ",(0,o.kt)("inlineCode",{parentName:"p"},"preimage"),", which allows them to receive the locked value. If they do not, the ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," can cancel the HTLC after a predefined ",(0,o.kt)("inlineCode",{parentName:"p"},"expiration")," time, recovering the locked value."),(0,o.kt)("p",null,"A single HTLC is not useful by itself\u2014it is simply a construction that promises to reward a particular recipient for revealing a preimage before a particular time, which is a fairly esoteric challenge."),(0,o.kt)("p",null,"The power comes when you have  ",(0,o.kt)("em",{parentName:"p"},"two")," HTLCs that use the same preimage, and which have staggered timeouts (so that a preimage that is revealed to complete the earlier-timeout HTLC can be used to complete the later-timeout HTLC). This allows parties to set up HTLCs so that both parties can be assured that either both HTLCs will complete, or neither will."),(0,o.kt)("p",null,"This assurance, ",(0,o.kt)("em",{parentName:"p"},"atomicity"),", is easy to achieve when both operations are occurring on the same ledger\u2014you can just include both operations in a single atomic transaction. But HTLCs allow you to enforce atomicity of transactions across ",(0,o.kt)("em",{parentName:"p"},"multiple ledgers"),", which do not need to know anything about each other (though they do each need to support hash locks and time locks.)"),(0,o.kt)("p",null,"These two ledgers can be separate blockchains, such as the Bitcoin and Ethereum networks, which means HTLCs can be used to make trustless trades of cryptocurrencies on different blockchains."),(0,o.kt)("p",null,"Alternatively, the two ledgers can be two different Bitcoin ",(0,o.kt)("em",{parentName:"p"},"payment channels"),"\u2014off-chain bilateral ledgers which can be settled trustlessly to the main chain. (A simple payment channel is described ",(0,o.kt)("a",{parentName:"p",href:"#transferwithtimeout"},"above"),".) This is how the Lightning Network allows multihop payments across a chain of payment channels."),(0,o.kt)("p",null,"Suppose Alice has a payment channel with Bob, and Bob has a payment channel with Charlie. If Alice wants to make a payment to Charlie over these channels, she can make a payment to Bob, and then Bob could make a payment to Charlie. However, how do Alice and Charlie guarantee that Bob won't cheat them, by receiving the payment from Alice but then neglecting to pay?"),(0,o.kt)("p",null,"Lightning solves this problems using HTLCs. Specifically, the parties embed HTLCs ",(0,o.kt)("em",{parentName:"p"},"within")," each of their payment channels. Charlie, as the ultimate recipient, generates a ",(0,o.kt)("inlineCode",{parentName:"p"},"hash"),". Alice and Bob create an HTLC in their payment channel, then Bob and Charlie create an HTLC in their payment channel, using the same hash. Once both HTLCs are created, Charlie can reveal the preimage to complete his HTLC, which means Bob will learn the preimage to complete his HTLC. The mechanics of embedding HTLCs within payment channels are very complex, and beyond the scope of this document, but the principle of each of the underlying HTLCs is essentially the same as in the one shown above."),(0,o.kt)("p",null,'You can also do atomic transactions between different combinations of ledgers, such as an atomic transaction between payment channels on different blockchains (which is what theoretically allows cross-blockchain payments on the Lightning Network), or an atomic transaction between a public ledger and a payment channel (known as a "',(0,o.kt)("a",{parentName:"p",href:"https://bitcoinmagazine.com/articles/pay-bitcoin-mainnet-lightning-and-back-submarine-swaps-are-now-live/"},"submarine swap"),'").'))}u.isMDXComponent=!0}}]);